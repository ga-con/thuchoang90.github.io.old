---
layout : default
---

# VEXRISCV 32-bit MCU

* * *

# I. VexRiscv CPU

VexRiscv CPU is a 5-stage 32-bit RISC-V CPU.

Original [repo](https://github.com/SpinalHDL/VexRiscv). Modified [repo](https://github.com/thuchoang90/VexRiscv)

## I. a) Make

First, git clone the folder:

	$ git clone -b dev-chip https://github.com/thuchoang90/VexRiscv.git		#commit 06f30990 on 28-Mar-2020
	$ cd VexRiscv/
	$ git submodule update --init --recursive

VexRiscv CPU has many build options:

	$ cd VexRiscv/			#go to your VexRiscv folder
	
	for smallest CPU:	$ sbt "runMain vexriscv.demo.GenSmallest"
	for GenFull CPU:	$ sbt "runMain vexriscv.demo.GenFull"
	for Linux CPU:	$ sbt "runMain vexriscv.demo.LinuxGen"
	for Briey SoC		$ sbt "runMain vexriscv.demo.Briey"		#GenFull CPU + bus + devices + IO

## I. b) SpinalHDL source-code library

VexRiscv CPUs are constructed based on the SpinalHDL library. Ref [link](https://github.com/SpinalHDL/SpinalHDL).

Actually, this library is downloaded and embedded into the system automatically while we are generating CPUs at those steps above. However, because it is hard to navigate the sources in an embedded library, it is recommended to git clone the library again in a separated folder for more accessible to search for the library source codes.

	$ git clone https://github.com/SpinalHDL/SpinalHDL.git		#branch master commit 647e8974 on 27-Mar-2020
	$ cd SpinalHDL/
	$ git submodule update --init --recursive
	(the library source-code are under the folder: lib/src/main/scala/spinal/lib/)

## I. c) Regression test

Self-test using Verilator:

	$ cd VexRiscv/		#go to your VexRiscv folder
	$ cd src/test/cpp/regression/

	for GenSmallest:	$ make clean run IBUS=SIMPLE DBUS=SIMPLE CSR=no MMU=no DEBUG_PLUGIN=no MUL=no DIV=no
	for GenFull:		$ make clean run
	for LinuxGen:		$ make clean run IBUS=CACHED DBUS=CACHED DEBUG_PLUGIN=STD DHRYSTONE=yes SUPERVISOR=yes MMU=yes CSR=yes DEBUG_PLUGIN=no COMPRESSED=no MUL=yes DIV=yes LRSC=yes AMO=yes REDO=10 TRACE=no COREMARK=yes LINUX_REGRESSION=yes

## I. d) Debug GenFull CPU with Verilator + OpenOCD + GDB

Open three terminals separately: one for Verilator, one for OpenOCD, and one for GDB.

On the first terminal, run Verilator:

	$ cd VexRiscv/						#go to your VexRiscv folder
	$ sbt "runMain vexriscv.demo.GenFull"	#make sure that GenFull is generated
	$ cd src/test/cpp/regression/
	$ make clean run DEBUG_PLUGIN_EXTERNAL=yes

On the second terminal, run OpenOCD:

	$ cd vexriscv_openocd/					#go to your vexriscv_openocd folder
	$ src/openocd -c "set VEXRISCV_YAML <cpu0.yaml PATH>" -f tcl/target/vexriscv_sim.cfg
		where <cpu0.yaml PATH> point to the file cpu0.yaml in the VexRiscv folder
		---> for example: $ src/openocd -c "set VEXRISCV_YAML /home/ubuntu/Projects/VexRiscv/cpu0.yaml" -f tcl/target/vexriscv_sim.cfg

Finally, on the third terminal, run GDB:

	$ echo $PATH											#check that if the riscv32im toolchain is on the PATH or not
	$ export PATH=/opt/gcc9/riscv32im/bin/:$PATH				#if not, then export the riscv32im toolchain to the PATH
	
	$ cd VexRiscv/										#go to your VexRiscv folder
	$ riscv32-unknown-elf-gdb src/test/resources/elf/uart.elf		#run the software with gdb tool
	$ target remote localhost:3333							#connect to the hardware (right now is emulated by verilator)
	$ monitor reset halt
	$ load
	$ continue
	(after this, it should prints messages to the Verilator terminal)

* * *

# II. Briey SoC

Briey SoC is a system consists of GenFull CPU + AXI bus + device modules (RAM, UART, GPIO, etc).

Birey SoC ig generated by **$ sbt "runMain vexriscv.demo.Briey"** in [I. a)](#i-a-make) )

## II. a) Briey SoC software demo

First, clone the Briey SoC software demo to your local machine.

	$ git clone https://github.com/thuchoang90/briey_software.git

This contains the first test demo under the **"test"** folder, and some other example demos.

## II. b) Debug Briey SoC with Verilator + OpenOCD + GDB

The Verilator emulates the Briey SoC. If you are using FPGA (or chip), then the real hardware will replace the Verilator. But the running scheme stays the same.

The OpenOCD makes the bridge between hardware and software.

The GDB is a native tool of the toolchain for debugging the hardware. The GDB can be replaced by other debugging tools such as Eclipse.

To debug the Briey SoC with Verilator + OpenOCD + GDB:

	First, run the Verilator:
	$ cd VexRiscv/								#cd to your VexRiscv folder
	$ sbt "runMain vexriscv.demo.Briey"				#make sure that Briey SoC is generated
	$ cd src/test/cpp/briey/
	$ make clean run
	
	Keep the Verilator terminal running, open a second terminal to run OpenOCD:
	$ cd vexriscv_openocd/							#cd to your vexriscv_openocd folder
	$ src/openocd -f tcl/interface/jtag_tcp.cfg -c "set BRIEY_CPU0_YAML <cpu0.yaml PATH>" -f tcl/target/briey.cfg
		where <cpu0.yaml PATH> point to the file cpu0.yaml in the VexRiscv folder
		---> for example: $ src/openocd -f tcl/interface/jtag_tcp.cfg -c "set BRIEY_CPU0_YAML /home/ubuntu/Projects/VexRiscv/cpu0.yaml" -f tcl/target/briey.cfg
	
	Keep both Verilator and OpenOCD terminals running, open a third terminal to run GDB:
	$ cd briey_software/							#cd to your briey_software/ folder
	$ echo ${PATH}								#check that if the riscv32im toolchain is on the PATH or not
	$ export PATH=/opt/gcc9/riscv32im/bin:$PATH		#if not, then export the riscv32im toolchain to the PATH
	$ riscv32-unknown-elf-gdb test/build/briey.elf
	$ target remote localhost:3333
	$ monitor reset halt
	$ load
	$ continue
	(after this, it should print messages in the Verilator terminal)

## II. c) Debug with Eclipse

Smae procedure as [II. b)](#ii-b-debug-briey-soc-with-verilator--openocd--gdb) with three separated terminals, just replace the GDB-terminal step with this Eclipse step.

Open the Eclipse tool, then import the example software folder:

	1. File --> Import... --> C/C++ --> Existing Code as Makefile Project --> Next >
	2. Browse to the software folder (i.e., briey_software/test/)
	3. Choose the "Cross GCC" (NOT the "RISC-V Cross GCC")
	4. Choose the project name as you wanted, then click Finish

After imported, remember to check the file resources/gcc.mk for the correct paths of your riscv32im toolchain.

To debug the program:

	1. Right click on the software project --> Debug As --> Debug Configurations...
	2. Choose the "GDB OpenOCD Debugging", then choose your debug configurations to debug

***note:*** if not yet config your Debug Configurations, then double-click on the "GDB OpenOCD Debugging" and follow these images to config it.

*(on the image **number 2**, remember to check the **correct path** for the riscv32im toolchain)*
![DebugConfig](./debug_configuration.png)

* * *

# BOTTOM PAGE

| Back | Next |
| :--- | ---: |
| [SiFive Freedom on VC707](./vc707.md) | [Scala Study Notes](./scala.md) |

